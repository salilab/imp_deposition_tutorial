Deposition of IMP models {#mainpage}
========================

[TOC]

# Introduction {#introduction}

In this tutorial we will introduce the procedure used to deposit integrative
modeling studies using [IMP](https://integrativemodeling.org/)
in the [PDB-Dev database](https://pdb-dev.wwpdb.org/) in mmCIF format.

# Study versus single model {#studyvmodel}

A frequently asked question is whether mmCIF files can be generated directly
from an [IMP::Model](@ref IMP::Model) or an
[RMF file](https://integrativemodeling.org/rmf/).
This generally isn't possible because RMF and IMP::Model are designed to
store one or more output models, where each model is a set of coordinates for
a single conformation of the system being studied. A deposition, on the other
hand, aims to cover a complete modeling study, and should capture the entire
ensemble of output models, all of the input data needed to reproduce the
modeling, and quality metrics such as the precision of the ensemble and the
degree to which it fits the output data. A deposition is also designed to
be visualized, and so may contain additional data not used in the modeling
itself, such as preset colors or views to match figures in the publication
or highlight regions of interest, and more human-descriptive names for parts
of the system. Thus, deposition is largely a data-gathering exercise, and
benefits from a modeling study being tidy and well organized (for example,
by storing it in a [GitHub](https://github.com) repository) so that data
is easy to find and track to its source.

# File format {#fileformat}

The file format used by PDB for deposition of integrative modeling studies
is the same [mmCIF format](http://mmcif.wwpdb.org/) that is used for crystal
structures, with extensions (the
[Integrative/Hybrid Methods (IHM) dictionary](http://mmcif.wwpdb.org/dictionaries/mmcif_ihm.dic/Index/))
to support coarse-grained structures, multiple input experimental data sources,
multiple states, multiple scales, and ensembles related by time or other
order. Currently, models that are compliant with the IHM dictionary can be
deposited in the [PDB-Dev](https://pdb-dev.wwpdb.org/) database.

mmCIF is a text format with a well-defined syntax, so in principle files
could be generated by hand or with simple scripts. However, it is generally
easier to use the existing [python-ihm](https://github.com/ihmwg/python-ihm)
library. This stores the same data as in an mmCIF file, but represents it as
a set of Python classes, so it is easier to manipulate. %IMP includes a
copy of the python-ihm library, and uses it internally to read and write
mmCIF files.

There are two main approaches to generating an mmCIF file for deposition:

 1. Use the [python-ihm](https://github.com/ihmwg/python-ihm) library directly,
    by writing a Python script that reads in output models and input data,
    adds annotations, and writes out an mmCIF file.
 2. Use the [ProtocolOutput](@ref IMP::pmi::mmcif::ProtocolOutput) class
    to automatically capture an entire IMP::pmi modeling protocol.

The first approach offers the greatest flexibility for custom protocols or
for modeling outside of %IMP itself, but does require everything to be done
manually. For a good example of this approach, see the
[modeling of Nup133](https://github.com/integrativemodeling/nup133/tree/master/outputs_foxs_ensemble_new/pdb-dev).
(One example of the tradeoff between flexibility and manual coding:
the crosslinks used in the study are stored in a
[plain text file](https://github.com/integrativemodeling/nup133/blob/master/Crosslinks/DSS_EDC_crosslinks.txt)
so a [custom Python class](https://github.com/integrativemodeling/nup133/blob/master/outputs_foxs_ensemble_new/pdb-dev/xlink.py)
had to be written to parse them.)

The second approach will be explored in this tutorial.

# Basic usage of ProtocolOutput {#basicusage}

[ProtocolOutput](@ref IMP::pmi::mmcif::ProtocolOutput) is designed to be
attached to a top-level PMI object (usually IMP::pmi::topology::System).
Then, as the
script is run, it will capture all of the information about the modeling
study, in an [ihm.System object](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System).
Additional information not in the modeling script itself, such as the
resulting publication, can be added using the
[python-ihm API](https://python-ihm.readthedocs.io/en/latest/usage.html).

First, we need to import the PMI and python-ihm Python modules:

\code{.py}
import IMP.pmi.mmcif
import ihm
\endcode

Next, as soon as the top-level IMP::pmi::topology::System object is created,
we attach a ProtocolOutput object:

\code{.py}
bs = IMP.pmi.macros.BuildSystem(m)

if '--mmcif' in sys.argv:
    # Record the modeling protocol to an mmCIF file
    po = IMP.pmi.mmcif.ProtocolOutput(open('rnapolii.cif', 'w'))
    bs.system.add_protocol_output(po)
    po.system.title = "Modeling of RNA Pol II"
    # Add publication
    po.system.citations.append(ihm.Citation.from_pubmed_id(25161197))
\endcode

Note that we only do this if the script is run with the `--mmcif` option.
Note also that the ProtocolOutput object `po` simply wraps an `ihm.System`
object as `po.system`. We can then customize the `ihm.System` by setting a
human-readable title and adding a citation (here we use
[ihm.Citation.from\_pubmed\_id](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.Citation.from_pubmed_id),
which looks up a citation by PubMed ID - this particular PubMed ID is
actually for the previously-published
[modeling of the Nup84 complex](https://salilab.org/nup84/)).

At the end of the modeling, we then simply write the entire study out to the
mmCIF file by using ProtocolOutput's `flush` method:

\code{.py}
if '--mmcif' in sys.argv:
    po.flush()
\endcode

As it is generally undesirable to rerun the entire modeling just to generate
an mmCIF file, we can save a lot of time by adding a 'dry run' option to the
script which skips the actual Monte Carlo simulation:

\code{.py}
bs.dry_run = '--dry-run' in sys.argv
...
c1=IMP.pmi.macros.ReplicaExchange0(m, ..., test_mode=bs.dry_run)
\endcode

Finally, we can run the script with the `--mmcif` and `--dry-run` options
to get the mmCIF output `rnapolii.cif`:

\code{.sh}
python modeling.py --mmcif --dry-run
\endcode

The `rnapolii.cif` file can be viewed in a text editor, or the `po.system`
object can be explored in a Python console. Each contains a great
deal of information about the system, including:

 - the software (%IMP and PMI) used in the modeling (in the `_software` table
   in the mmCIF file, or as [po.system.software](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.software) in Python).
 - cited papers (`_citation` table or [po.system.citations](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.citations) Python object).
 - the entities (unique polymer sequences) that make up the system
   (`_entity`, `_entity_poly`, `_entity_poly_seq` tables or [po.system.entities](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.entities)).
 - each asymmetric unit (instance of an entity) (`_struct_asym` table or [po.system.asym\_units](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.asym_units)).
 - assemblies (collections of entities and/or asymmetric units that represent
   a subset of the system, such as everything modeled in a given state, or
   everything that fits into an electron microscopy density map) (`_ihm_struct_assembly` table or [po.system.complete\_assembly](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.complete_assembly)).
 - input experimental information, such as crystal structures, comparative
   models, or cross-links (`_ihm_dataset_list` table or [ihm.dataset objects](https://python-ihm.readthedocs.io/en/latest/dataset.html)).
 - information about each restraint, such as cross-linking (`_ihm_cross_link_list` table or [ihm.restraint.CrossLinkRestraint objects](https://python-ihm.readthedocs.io/en/latest/restraint.html#ihm.restraint.CrossLinkRestraint)).
 - the Monte Carlo simulation (`_ihm_modeling_protocol` table or [ihm.protocol objects](https://python-ihm.readthedocs.io/en/latest/protocol.html)).

# Linking to other data {#linking}

Integrative modeling draws on data from a variety of sources, so for a
complete deposition all of this data needs to be available. The data is not
placed directly in the mmCIF file - rather, the file contains links. These
links can be:

 - an identifier in a domain-specific database, such as
   [PDB](https://www.wwpdb.org/) or [EMDB](https://www.ebi.ac.uk/pdbe/emdb/).
 - a [DOI](https://www.doi.org/) where the files can be obtained.
 - a path to a file on the local disk.

Database identifiers are preferable because the databases are curated by
domain experts and include domain-specific information, and the files are
in standard formats. ProtocolOutput will attempt to use these where possible.
For example, in this case ProtocolOutput is able to read the annotations of
the input crystal structure used for the modeling ([see below](@ref annotation))
and determine that it is stored in the PDB, so the relevant
[1WCM](https://www.rcsb.org/structure/1WCM) identitifer is included in the
mmCIF file (see the `_ihm_dataset_related_db_reference` table).

When a file is used for the modeling which cannot be tracked back to a database,
ProtocolOutput will include its path (relative to that of the mmCIF file).
For example, in this case the cross-links used are stored in simple CSV
files. In addition, the Python script itself is linked from the mmCIF file.
Such local paths won't be available to end users, so for deposition we need
to replace these paths with database IDs or DOIs ([see below](@ref polishing)).

As a further example of linkage, see the links in the previously-published
[modeling of the Nup84 complex](https://salilab.org/nup84/) below. The mmCIF
file links to the data directly used in the modeling (cross-links, crystal
structures, electron microscopy class averages, comparative models, and
Python scripts) via database IDs or DOIs. Furthermore, where available links
are provided from this often-processed data back to the original data, such
as templates for comparative models, mass spectometry spectra for cross-links,
or micrographs for class averages:

\image html links.png width=700px

# Annotation of input files {#annotation}

ProtocolOutput will look at all input files to try to extract as much metadata
as possible. As [described above](@ref linking) this is used to look up database
identifiers, but it can also detect other inputs, such as the templates used
for comparative modeling. Thus, it is important for deposition that all input
files are annotated as well as possible:

 - for PDB crystal structures, do not remove the original headers, such as
   the `HEADER` and `TITLE` lines.
 - for MODELLER comparative models, leave in the `REMARK` records and make sure
   that any files mentioned in `REMARK   6 ALIGNMENT:` or
   `REMARK   6 SCRIPT:` records are available (modify the paths if necessary).
 - for manually generated PDB files, such as those extracted from a published
   work or generated by docking or other means, add suitable `EXPDTA` and
   `TITLE` records to the files for ProtocolOutput to pick up. See the
   [python-ihm docs](https://python-ihm.readthedocs.io/en/latest/metadata.html#ihm.metadata.PDBParser.parse_file)
   for more information.

# Polishing the deposition {#polishing}

ProtocolOutput attempts to automatically generate as much as possible of the
mmCIF file, but there are some areas where manual intervention is necessary
because the data is missing, or its guess was incomplete. This data can be
corrected by manipulating the [ihm.System object](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System)
directly, at the script, immediately before we call ProtocolOutput's `flush`
method. We will look at a few examples in this section.

## Cross-linker type {#xltype}

For cross-linking experiments, the mmCIF file contains a description of the
cross-linking reagent used. This information is not in the CSV file or the
Python script. ProtocolOutput guesses the name of the reagent using the
`label` passed to the PMI [CrossLinkingMassSpectrometryRestraint](@ref IMP::pmi::restraints::crosslinking::CrossLinkingMassSpectrometryRestraint),
as this label is often the name of the cross-linker. However, in this case it
is not (we used the labels `Trnka` and `Chen` respectively for the datasets
from [Al Burlingame's lab](http://www.mcponline.org/content/13/2/420.long) and
[Juri Rappsilber's lab](http://emboj.embopress.org/content/29/4/717)).
We can correct this by looking up the publications to determine
that the [DSS](https://en.wikipedia.org/wiki/Disuccinimidyl_suberate)
and [BS3](https://en.wikipedia.org/wiki/Bissulfosuccinimidyl_suberate)
cross-linkers were used, respectively, and using the python-ihm
API to set the correct
[cross-linker type](https://python-ihm.readthedocs.io/en/latest/cross_linkers.html)
for each [cross-linking restraint](https://python-ihm.readthedocs.io/en/latest/restraint.html#ihm.restraint.CrossLinkRestraint)
in the [list of all restraints](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.restraints):

\code{.py}
if '--mmcif' in sys.argv:
    import ihm.cross_linkers
    trnka, chen = [r for r in po.system.restraints if hasattr(r, 'linker')]
    trnka.linker = ihm.cross_linkers.dss
    chen.linker = ihm.cross_linkers.bs3
\endcode

## Correct number of output models {#fixnummodel}

ProtocolOutput correctly notes that we ran Monte Carlo to generate 20000 frames.
However, in many modeling scenarios the modeling script is run multiple times
on a compute cluster to generate several independent trajectories which are
then combined. ProtocolOutput cannot know whether this happened. However, it
is straightforward to use the python-ihm API to manually change the number
of output models to match that reported in the publication:

\code{.py}
if '--mmcif' in sys.argv:
    # Correct number of output models to account for multiple runs
    protocol = po.system.orphan_protocols[-1]
    protocol.steps[-1].num_models_end = 200000
\endcode

## Add model coordinates {#addcoords}

The current mmCIF file contains all of the input data, and notes that Monte
Carlo was used to generate frames, but doesn't actually store any of those
coordinates in the file. Ultimately this information will be added automatically
by PMI model analysis and validation scripts, but for the time being any
information about clustering, localization densities, and final models needs
to be added to the file using the python-ihm API:

\code{.py}
if '--mmcif' in sys.argv:
    # Get last protocol in the file
    protocol = po.system.orphan_protocols[-1]
    # State that we filtered the 200000 frames down to one cluster of
    # 100 models:
    analysis = ihm.analysis.Analysis()
    protocol.analyses.append(analysis)
    analysis.steps.append(ihm.analysis.ClusterStep(
                            feature='RMSD', num_models_begin=200000,
                            num_models_end=100))
    # Create an ensemble for the cluster (warning: _add_simple_ensemble
    # is subject to change in future IMP releases) and deposit a single
    # representative model (let's say it's frame 42 from the output RMF file)
    e = po._add_simple_ensemble(analysis.steps[-1],
                                name="Cluster 0", num_models=100,
                                drmsd=12.2, num_models_deposited=1,
                                localization_densities={}, ensemble_file=None)
    # Add the model from RMF
    rh = RMF.open_rmf_file_read_only('output/rmfs/0.rmfs')
    IMP.rmf.link_hierarchies(rh, [root_hier])
    IMP.rmf.load_frame(rh, RMF.FrameID(42))
    del rh
    model = po.add_model(e.model_group)
\endcode

If localization densities are available for the cluster, we can link to those
too. For example, to add the density of the Rpb4 subunit for the entire cluster:

\code{.py}
# Look up the ihm.AsymUnit corresponding to a PMI component name
asym = po.asym_units['Rpb4.0']
# Add path to a local output file
loc = ihm.location.OutputFileLocation('output/cluster0.Rpb4.mrc')
den = ihm.model.LocalizationDensity(file=loc, asym_unit=asym)
# Add to ensemble
e.densities.append(den)
\endcode

## Replace local links with DOIs {#adddois}

[Recall from earlier](@ref linking) that ProtocolOutput adds local paths to
the cross-link CSV files and the Python script itself, which won't be visible
to end users. The simplest way to solve this issue is to put some or all of the
files in zipfiles and upload them to a service that provides a DOI, such as
[Zenodo](https://zenodo.org/) or [FigShare](https://figshare.com/), and then
link to that DOI. We can do this by creating an
[ihm.location.Repository object](https://python-ihm.readthedocs.io/en/latest/location.html#ihm.location.Repository)
for each zipfile, and then using the [update_locations_in_repositories](https://python-ihm.readthedocs.io/en/latest/main.html#ihm.System.update_locations_in_repositories)
function to map local paths to files in the zipfile at the DOI:

\code{.py}
if '--mmcif' in sys.argv:
    import ihm.location
    repo = ihm.location.Repository(doi="10.5281/zenodo.1218053", root="..",
                   url="https://zenodo.org/record/1218053/files/tutorial.zip")
    po.system.update_locations_in_repositories([repo])
\endcode

This assumes that `tutorial.zip` at the given DOI and URL was created by
archiving all files under the parent directory (`..`). Thus the cross-link
file which was previously linked with the local path `../data/polii_xlinks.csv`
can now be found by downloading `tutorial.zip` and extracting
`data/polii_xlinks.csv` from it.

# Visualization {#visualization}

mmCIF files can be viewed in many viewers. However, most viewers do not yet
support the integrative modeling extensions, and so may only show the atomic
parts of the model (if any). Integrative models can be viewed in
[ChimeraX](https://www.rbvi.ucsf.edu/chimerax/) - be sure to use a recent
nightly build, and open the file using the `format ihm` option,
e.g. `open rnapolii.cif format ihm`. [VMD](http://www.ks.uiuc.edu/Research/vmd/)
is also reportedly working on support in their forthcoming 1.9.4 release.
